<?xml version="1.0" encoding="UTF-8"?>   
<fps version="1.1" url="http://code.google.com/p/freeproblemset/">
	<generator name="HUSTOJ" url="http://code.google.com/p/hustoj/"/>
	<item>
<title><![CDATA[公共汽车]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>小明坐公交车去学校，他从公交站台上车后，数了一下车上的人数。此后公交车每次到站，小明都数一下有多少名乘客上车，小明下车之前，又数了一下车上剩下的乘客的数目，问其间有多少名乘客下车。</p>
<p></p>]]></description>
<input><![CDATA[<p>输入数据的第一行是一个整数N(1&lt;=N&lt;=100)，表示小明坐车经过了多少站。接下来N行每行包含一个整数x(0&lt;=x&lt;=10)，表示在这一站有多少名乘客上车。此后还有一行包含两个整数A(0&lt;=N&lt;=20)和B(0&lt;=N&lt;=20)，分别表示小明上车时车上乘客的数目和他下车时车上乘客的数目。</p>
<p></p>]]></input> 
<output><![CDATA[<p>输出数据只有一行，是小明坐车期间下车乘客的数目。</p>
<p></p>]]></output>
<sample_input><![CDATA[3
5
6
7
8 9]]></sample_input>
<sample_output><![CDATA[17]]></sample_output>
<test_input><![CDATA[100
7
9
7
6
5
0
0
6
5
7
1
10
4
1
0
7
6
2
10
9
7
1
3
7
4
0
4
9
1
3
9
9
1
3
4
4
3
2
10
7
9
0
4
0
0
4
7
6
5
5
4
10
4
6
7
8
6
9
4
5
1
0
3
1
1
8
5
2
8
3
9
7
1
3
5
1
5
2
8
10
7
10
10
9
5
6
6
9
4
8
4
4
8
5
5
7
0
8
9
9
1 146
]]></test_input>
<test_output><![CDATA[367
]]></test_output>
<test_input><![CDATA[100
9
10
8
7
9
4
5
8
0
1
1
4
0
3
4
10
8
10
1
3
3
9
9
6
7
3
4
5
2
6
10
0
3
5
6
0
9
9
8
8
8
7
10
6
10
1
5
5
9
4
7
2
1
5
8
8
6
0
0
8
4
9
7
8
3
0
8
2
9
3
8
6
0
7
1
8
6
4
1
5
9
8
7
10
0
2
5
7
2
3
2
7
1
7
2
5
7
8
5
3
15 493
]]></test_input>
<test_output><![CDATA[48
]]></test_output>
<test_input><![CDATA[100
2
3
2
1
10
1
1
6
1
6
0
4
8
0
5
8
2
5
2
4
9
9
10
3
9
8
2
1
7
7
8
9
10
8
8
8
7
10
3
8
3
1
2
0
2
5
6
4
10
7
8
9
5
5
10
2
2
10
1
7
7
9
6
4
6
1
1
1
0
5
9
1
6
0
10
6
6
6
8
3
2
3
10
5
8
9
7
8
7
7
5
3
5
9
5
10
10
7
0
9
3 107
]]></test_input>
<test_output><![CDATA[434
]]></test_output>
<test_input><![CDATA[100
10
3
8
10
10
1
3
7
2
3
0
2
8
6
0
3
4
7
10
9
8
2
5
3
1
4
8
10
0
7
7
0
10
4
8
7
3
0
2
5
3
0
7
9
6
6
1
10
0
0
6
9
3
0
10
2
3
5
2
3
1
9
1
9
0
9
6
3
7
6
6
10
6
3
9
1
7
8
10
7
9
5
3
10
4
2
1
5
7
1
6
6
10
8
5
8
4
9
0
1
12 357
]]></test_input>
<test_output><![CDATA[162
]]></test_output>
<test_input><![CDATA[100
3
9
7
2
7
7
1
1
6
6
3
3
4
3
9
1
0
0
9
9
8
2
5
7
0
4
0
4
0
4
10
1
2
4
3
7
0
2
8
5
6
9
6
0
2
2
1
2
2
9
0
8
0
3
3
0
8
3
2
8
5
10
9
8
3
10
2
3
10
0
6
6
9
1
4
9
3
3
0
4
1
9
1
1
2
4
10
8
6
10
5
0
9
1
6
1
9
9
3
6
2 185
]]></test_input>
<test_output><![CDATA[263
]]></test_output>
<test_input><![CDATA[100
8
7
5
7
4
7
7
8
5
1
10
7
8
0
6
10
8
9
4
2
4
3
10
3
5
2
10
8
10
5
0
5
10
6
10
3
0
7
10
5
6
9
10
4
9
5
3
7
2
8
7
4
9
4
5
1
7
4
10
6
8
8
0
7
3
9
0
1
5
8
4
0
6
4
2
2
9
6
7
9
1
3
3
8
8
8
9
4
0
8
8
8
4
6
4
7
4
2
9
7
4 475
]]></test_input>
<test_output><![CDATA[97
]]></test_output>
<test_input><![CDATA[100
6
10
6
2
1
4
0
6
3
1
8
7
5
3
7
4
9
10
2
0
10
8
5
0
4
6
0
10
3
10
10
7
10
3
7
9
7
8
2
10
7
10
4
1
0
10
4
9
7
6
8
6
2
2
7
6
6
5
5
7
4
4
4
3
6
9
10
2
4
1
0
10
9
4
0
10
1
2
6
9
7
1
4
9
3
9
2
10
3
7
6
8
9
8
9
4
5
9
5
9
18 288
]]></test_input>
<test_output><![CDATA[290
]]></test_output>
<test_input><![CDATA[100
2
6
10
7
3
7
1
4
4
8
9
1
4
0
6
7
9
10
6
7
10
0
7
3
4
4
0
1
7
6
8
10
0
8
4
3
4
5
8
9
0
4
8
4
4
1
0
0
0
7
6
8
7
2
0
9
7
9
0
1
5
8
0
5
5
4
6
8
7
1
4
7
6
10
1
8
0
10
7
1
6
2
7
0
2
6
10
7
4
8
9
7
5
9
10
9
1
6
4
6
13 378
]]></test_input>
<test_output><![CDATA[145
]]></test_output>
<test_input><![CDATA[100
5
2
7
10
1
1
10
7
1
4
7
0
2
10
4
6
7
6
3
9
10
9
3
2
5
4
0
4
2
9
10
5
9
6
2
0
5
2
7
6
4
1
4
7
10
6
0
6
2
4
4
10
2
7
0
6
9
9
8
0
7
7
5
6
0
6
4
5
8
9
10
10
0
3
4
10
10
5
3
10
9
5
7
9
1
7
2
0
5
10
9
0
6
2
6
4
8
10
10
3
4 473
]]></test_input>
<test_output><![CDATA[67
]]></test_output>
<test_input><![CDATA[100
6
3
4
8
6
1
1
0
10
0
4
0
8
10
7
7
1
7
2
9
2
6
2
4
1
5
7
8
10
4
8
3
6
2
1
10
3
0
10
0
1
1
1
7
0
8
3
1
2
4
8
4
10
9
8
9
3
2
6
0
5
2
4
0
4
3
8
5
3
7
5
2
9
4
10
7
1
0
9
1
4
4
5
4
2
1
0
3
1
7
4
6
9
6
4
0
9
1
5
1
18 307
]]></test_input>
<test_output><![CDATA[149
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[TJ-NOIP-2009]]></source>
	<solution language="C"><![CDATA[#include <stdio.h>

int main (int argc, char const* argv[])
{
    int a, b, n, sum, tmp;

    scanf("%d", &n);
    sum = 0;
    while (n--) {
        scanf("%d", &tmp);
        sum += tmp;
    }
    scanf("%d %d", &a, &b);

    printf("%d\n", a + sum - b);

    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[名次]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>N个小朋友在参加考试，他们的成绩是0到100之间的整数，给出小朋友的成绩和其他N-1个小朋友的成绩，问小明在这次考试中的名次是多少？(如果有k个小朋友的分数比小明高，那么小明的名次就是k+1)</p>
<p></p>]]></description>
<input><![CDATA[<p>输入数据只有一行，包含一个正整数N(1&lt;=N&lt;=10000)，表示参赛的小朋友数。接下来有N个整数，其中的第一个是小明的成绩，剩下的是其他小朋友的成绩。</p>
<p></p>]]></input> 
<output><![CDATA[<p>输出数据只有一行，包含一个整数，表示小明在这次考试中所取得的名次。</p>
<p></p>]]></output>
<sample_input><![CDATA[5
100 99 98 100 100]]></sample_input>
<sample_output><![CDATA[1]]></sample_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[TJ-NOIP-2009]]></source>
	<solution language="C"><![CDATA[#include <stdio.h>

int main (int argc, char const* argv[])
{
    int n, m, ans, score;

    scanf("%d", &n);
    scanf("%d", &m); n--;
    ans = 1;
    while (n--) {
        scanf("%d", &score);
        if (score > m) {
            ans++;
        }
    }

    printf("%d\n", ans);

    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[宝箱]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>小明和小刚发现了一个宝箱，里面有十颗钻石。这些钻石有大有小，价值不一。小明和小刚希望能够尽量公平地把这些宝石分成两份（两部分包含的报数的数目不一定相等），然后每人拿走其中的一部分。现在给出每颗宝石的价值，问分成的两部分的总价值之差最少是多少？</p>
<p></p>]]></description>
<input><![CDATA[<p>输入数据的第一行包含一个正整数T(T&lt;=100)，表示测试数据的组数。接下来有T行，每行表示一组测试数据，每行包含用空格隔开的十个整数，分别表示十颗宝石的价值，这些宝石的价值在1到1000之间。</p>
<p></p>]]></input> 
<output><![CDATA[<p>输出应包含T行，每行对应一组输入数据。每行包含一个非负整数，表示把宝石分成两部分之后，两部分价值相差的最小值。</p>
<p></p>]]></output>
<sample_input><![CDATA[2
1 1 1 1 1 1 1 1 1 2
1 1 1 1 1 1 1 1 1 3]]></sample_input>
<sample_output><![CDATA[1
0]]></sample_output>
<test_input><![CDATA[10
731 505 719 155 438 808 218 853 625 903
190 752 827 381 257 679 181 722 636 508
551 992 166 680 956 538 866 300 399 625
836 831 129 451 584 847 404 646 751 425
268 661 30 304 875 52 806 610 16 918
84 665 156 808 20 462 657 71 478 587
965 130 334 295 633 714 22 247 335 751
181 598 239 169 475 826 752 588 263 992
532 527 536 596 461 512 103 209 786 145
581 71 195 675 205 969 799 596 369 744
]]></test_input>
<test_output><![CDATA[1
1
1
2
2
2
16
19
1
12
]]></test_output>
<test_input><![CDATA[10
263 252 196 108 25 306 983 741 405 522
132 499 761 910 158 742 936 831 644 816
870 696 940 561 357 995 466 199 32 433
301 748 338 322 471 103 92 873 782 828
446 406 981 357 386 534 80 676 823 324
66 321 805 471 536 193 625 348 518 344
308 248 846 332 884 9 588 102 705 678
574 17 399 105 205 561 553 924 274 826
41 946 581 705 648 956 436 355 510 961
605 481 911 624 57 826 671 926 221 120
]]></test_input>
<test_output><![CDATA[1
1
17
2
1
3
20
10
9
2
]]></test_output>
<test_input><![CDATA[10
957 298 366 664 404 545 431 533 434 503
115 42 697 750 123 411 263 971 671 517
527 420 847 937 193 172 294 396 258 89
464 266 443 709 96 690 285 651 781 251
309 331 154 33 912 798 831 925 309 729
293 539 623 955 481 140 173 202 122 159
530 430 162 456 32 638 266 413 236 4
128 481 741 629 173 305 470 995 166 4
769 896 941 384 192 622 451 410 305 799
305 849 348 139 822 42 480 269 511 169
]]></test_input>
<test_output><![CDATA[5
0
1
4
3
3
3
2
9
12
]]></test_output>
<test_input><![CDATA[10
756 238 762 666 175 972 99 472 184 620
798 95 497 623 542 923 12 943 48 167
973 405 488 566 703 18 484 142 205 255
51 893 168 352 391 944 256 141 235 803
692 735 878 663 278 538 140 681 693 603
992 123 550 673 636 276 354 444 674 571
828 459 17 436 98 129 798 69 29 925
1 753 138 295 567 197 31 736 157 104
875 69 536 484 548 460 623 602 624 897
398 492 896 948 123 572 734 248 185 493
]]></test_input>
<test_output><![CDATA[4
2
3
6
7
7
6
1
2
1
]]></test_output>
<test_input><![CDATA[10
461 924 281 640 644 218 397 917 828 350
875 239 990 597 948 974 924 772 478 380
653 288 692 584 710 933 18 404 430 228
496 952 956 487 514 244 913 841 58 686
958 238 102 199 531 808 312 36 182 259
54 953 69 690 460 750 372 786 926 535
97 678 93 873 50 788 954 114 927 661
87 999 929 775 722 342 28 159 754 193
66 884 953 70 322 845 127 281 136 805
667 614 622 596 306 689 682 50 106 237
]]></test_input>
<test_output><![CDATA[2
7
6
9
1
7
3
4
1
1
]]></test_output>
<test_input><![CDATA[10
829 84 635 629 682 921 964 304 642 364
16 717 898 53 264 824 751 558 92 496
963 277 152 618 333 743 632 559 27 40
323 149 925 703 953 427 76 161 990 326
442 275 726 373 931 901 177 749 197 570
416 922 479 17 397 139 900 559 744 654
393 353 597 517 527 477 568 37 599 326
281 806 365 9 592 998 321 176 649 460
273 730 53 998 392 911 894 785 109 467
725 879 624 461 790 419 296 611 791 505
]]></test_input>
<test_output><![CDATA[0
1
0
5
3
1
2
1
4
1
]]></test_output>
<test_input><![CDATA[10
41 449 328 474 150 709 467 329 936 440
700 117 258 811 952 491 993 931 823 431
359 590 899 153 292 370 404 698 699 876
442 705 757 527 868 893 642 273 18 885
675 788 291 303 656 660 126 704 225 862
522 617 630 725 17 847 715 732 502 778
304 32 168 841 288 76 31 934 245 626
419 782 875 723 346 335 992 70 369 545
610 611 60 935 738 829 962 369 918 282
928 407 602 312 532 517 102 80 907 525
]]></test_input>
<test_output><![CDATA[3
1
8
4
0
13
3
4
0
2
]]></test_output>
<test_input><![CDATA[10
532 763 17 194 170 31 844 604 213 733
904 356 225 742 940 941 295 694 386 4
335 971 527 487 566 506 947 319 67 896
126 165 927 47 406 592 147 405 372 699
606 783 356 63 549 20 722 112 784 989
248 646 913 808 462 354 995 130 212 824
611 9 605 182 671 649 657 613 883 343
395 439 995 255 211 449 287 618 277 242
148 113 305 209 82 4 171 59 297 842
26 131 330 249 892 673 614 883 888 558
]]></test_input>
<test_output><![CDATA[11
13
1
6
0
6
25
0
2
18
]]></test_output>
<test_input><![CDATA[10
668 402 1000 80 65 768 483 946 281 824
572 503 200 641 701 361 1 149 462 222
152 517 612 893 584 698 787 223 750 180
971 538 303 411 77 236 571 635 969 847
891 64 524 684 529 660 768 247 511 972
261 929 863 522 222 483 290 843 592 295
111 448 125 62 542 734 872 86 409 524
589 943 1 560 28 522 322 86 941 625
387 437 44 677 587 331 608 28 200 757
925 868 132 690 942 831 409 595 748 40
]]></test_input>
<test_output><![CDATA[1
4
6
4
2
8
3
23
4
0
]]></test_output>
<test_input><![CDATA[10
295 609 917 434 580 244 503 525 776 273
218 998 839 577 975 670 192 465 90 329
493 586 285 494 441 175 445 612 560 777
784 266 570 778 982 130 452 599 520 280
32 155 172 628 951 185 796 866 137 500
186 632 248 35 308 624 336 882 857 405
840 122 821 415 860 967 312 633 11 694
554 448 865 365 70 702 598 508 983 843
844 674 388 780 240 407 998 575 158 275
61 395 589 734 823 902 165 152 696 172
]]></test_input>
<test_output><![CDATA[6
1
2
1
0
1
3
8
9
3
]]></test_output>
<hint><![CDATA[]]></hint>
<source><![CDATA[TJ-NOIP-2009]]></source>
	<solution language="C"><![CDATA[#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int abs (int n)
{
    return n >= 0 ? n : -n;
}

int main (int argc, char const* argv[])
{
    int ruler[10], a[10];
    int i, j, t, total, sum, ans, temp;

    scanf("%d", &t);

    while (t--) {
        total = 0;
        for (i = 0; i < 10; i++) {
            scanf("%d", &a[i]);
            total += a[i];
        }
        ans = total;

        memset(ruler, 0, sizeof(int) * 10);
        for (i = 0; i < 1024; i++) {

            sum = 0;
            for (j = 0; j < 10; j++) {
                sum += a[j] * ruler[j];
            }
    
            temp = abs((total - sum) - sum);
            if (ans > temp) {
                ans = temp;
            }
    
            ruler[0]++;
            for (j = 0; j < 9; j++) {
                if (ruler[j] > 1) {
                    ruler[j] = 0; ruler[j+1]++;
                }
            }
        }

        printf("%d\n", ans);
    }


    return 0;
}]]></solution>
	</item>
<item>
<title><![CDATA[解方程]]></title>
<time_limit unit="s"><![CDATA[1]]></time_limit>
<memory_limit unit="mb"><![CDATA[128]]></memory_limit>

<description><![CDATA[<p>已知整数r，求满足方程x^2 + y^2 + z^2 = r的非负整数解的个数，即要求x, y, z是正整数或零。</p>
<p></p>]]></description>
<input><![CDATA[<p>输入数据包含一个整数r(1&lt;=r&lt;=1000)。</p>
<p></p>]]></input> 
<output><![CDATA[<p>输出一个整数，表示对应方程的非负整数解的个数。</p>
<p></p>]]></output>
<sample_input><![CDATA[42]]></sample_input>
<sample_output><![CDATA[6]]></sample_output>
<test_input><![CDATA[994
]]></test_input>
<test_output><![CDATA[24
]]></test_output>
<test_input><![CDATA[995
]]></test_input>
<test_output><![CDATA[24
]]></test_output>
<test_input><![CDATA[997
]]></test_input>
<test_output><![CDATA[24
]]></test_output>
<test_input><![CDATA[996
]]></test_input>
<test_output><![CDATA[18
]]></test_output>
<test_input><![CDATA[991
]]></test_input>
<test_output><![CDATA[0
]]></test_output>
<test_input><![CDATA[999
]]></test_input>
<test_output><![CDATA[0
]]></test_output>
<test_input><![CDATA[1000
]]></test_input>
<test_output><![CDATA[24
]]></test_output>
<test_input><![CDATA[992
]]></test_input>
<test_output><![CDATA[12
]]></test_output>
<test_input><![CDATA[993
]]></test_input>
<test_output><![CDATA[18
]]></test_output>
<test_input><![CDATA[998
]]></test_input>
<test_output><![CDATA[39
]]></test_output>
<hint><![CDATA[<p>这6组解分别是<br />
x=1, y=4, z=5<br />
x=1, y=5, z=4<br />
x=4, y=1, z=5<br />
x=4, y=5, z=1<br />
x=5, y=1, z=4<br />
x=5, y=4, z=1</p>
<p></p>]]></hint>
<source><![CDATA[TJ-NOIP-2009]]></source>
	<solution language="C"><![CDATA[#include <stdio.h>
#include <stdlib.h>

int main (int argc, char const* argv[])
{
    int r, s[33], i, j, k, cnt;

    scanf("%d", &r);

    for (i = 0; i < 33; i++) {
        s[i] = i * i;
    }

    cnt = 0;
    for (i = 0; i < 33; i++) {
        for (j = 0; j < 33; j++) {
            for (k = 0; k < 33; k++) {
                if (s[i] + s[j] + s[k] == r) {
                    cnt++;
                }
            }
        }
    }

    printf("%d\n", cnt);

    return 0;
}]]></solution>
	</item>
</fps>